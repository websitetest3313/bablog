"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _styledBase = _interopRequireDefault(require("@emotion/styled-base"));

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactImmutableProptypes = _interopRequireDefault(require("react-immutable-proptypes"));

var _core = require("@emotion/core");

var _immutable = require("immutable");

var _slate = require("slate");

var _slateReact = require("slate-react");

var _serializers = require("../serializers");

var _Toolbar = _interopRequireDefault(require("../MarkdownControl/Toolbar"));

var _renderers = require("./renderers");

var _validators = require("./validators");

var _plugins = _interopRequireWildcard(require("./plugins"));

var _keys = _interopRequireDefault(require("./keys"));

var _visualEditorStyles = _interopRequireDefault(require("./visualEditorStyles"));

var _styles = require("../styles");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const VisualEditorContainer = (0, _styledBase.default)("div", {
  target: "evezps90",
  label: "VisualEditorContainer"
})(process.env.NODE_ENV === "production" ? {
  name: "79elbk",
  styles: "position:relative;"
} : {
  name: "79elbk",
  styles: "position:relative;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9NYXJrZG93bkNvbnRyb2wvVmlzdWFsRWRpdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtCd0MiLCJmaWxlIjoiLi4vLi4vLi4vc3JjL01hcmtkb3duQ29udHJvbC9WaXN1YWxFZGl0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBJbW11dGFibGVQcm9wVHlwZXMgZnJvbSAncmVhY3QtaW1tdXRhYmxlLXByb3B0eXBlcyc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgeyBDbGFzc05hbWVzIH0gZnJvbSAnQGVtb3Rpb24vY29yZSc7XG5pbXBvcnQgeyBnZXQsIGlzRW1wdHksIGRlYm91bmNlLCB1bmlxIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IHsgVmFsdWUsIERvY3VtZW50LCBCbG9jaywgVGV4dCB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IEVkaXRvciBhcyBTbGF0ZSB9IGZyb20gJ3NsYXRlLXJlYWN0JztcbmltcG9ydCB7IHNsYXRlVG9NYXJrZG93biwgbWFya2Rvd25Ub1NsYXRlLCBodG1sVG9TbGF0ZSB9IGZyb20gJy4uL3NlcmlhbGl6ZXJzJztcbmltcG9ydCBUb29sYmFyIGZyb20gJy4uL01hcmtkb3duQ29udHJvbC9Ub29sYmFyJztcbmltcG9ydCB7IHJlbmRlck5vZGUsIHJlbmRlck1hcmsgfSBmcm9tICcuL3JlbmRlcmVycyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU5vZGUgfSBmcm9tICcuL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHBsdWdpbnMsIHsgRWRpdExpc3RDb25maWd1cmVkIH0gZnJvbSAnLi9wbHVnaW5zJztcbmltcG9ydCBvbktleURvd24gZnJvbSAnLi9rZXlzJztcbmltcG9ydCB2aXN1YWxFZGl0b3JTdHlsZXMgZnJvbSAnLi92aXN1YWxFZGl0b3JTdHlsZXMnO1xuaW1wb3J0IHsgRWRpdG9yQ29udHJvbEJhciB9IGZyb20gJy4uL3N0eWxlcyc7XG5cbmNvbnN0IFZpc3VhbEVkaXRvckNvbnRhaW5lciA9IHN0eWxlZC5kaXZgXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbmA7XG5cbmNvbnN0IGNyZWF0ZUVtcHR5UmF3RG9jID0gKCkgPT4ge1xuICBjb25zdCBlbXB0eVRleHQgPSBUZXh0LmNyZWF0ZSgnJyk7XG4gIGNvbnN0IGVtcHR5QmxvY2sgPSBCbG9jay5jcmVhdGUoeyBvYmplY3Q6ICdibG9jaycsIHR5cGU6ICdwYXJhZ3JhcGgnLCBub2RlczogW2VtcHR5VGV4dF0gfSk7XG4gIHJldHVybiB7IG5vZGVzOiBbZW1wdHlCbG9ja10gfTtcbn07XG5cbmNvbnN0IGNyZWF0ZVNsYXRlVmFsdWUgPSByYXdWYWx1ZSA9PiB7XG4gIGNvbnN0IHJhd0RvYyA9IHJhd1ZhbHVlICYmIG1hcmtkb3duVG9TbGF0ZShyYXdWYWx1ZSk7XG4gIGNvbnN0IHJhd0RvY0hhc05vZGVzID0gIWlzRW1wdHkoZ2V0KHJhd0RvYywgJ25vZGVzJykpO1xuICBjb25zdCBkb2N1bWVudCA9IERvY3VtZW50LmZyb21KU09OKHJhd0RvY0hhc05vZGVzID8gcmF3RG9jIDogY3JlYXRlRW1wdHlSYXdEb2MoKSk7XG4gIHJldHVybiBWYWx1ZS5jcmVhdGUoeyBkb2N1bWVudCB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkaXRvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgb25BZGRBc3NldDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRBc3NldDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvbk1vZGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgZmllbGQ6IEltbXV0YWJsZVByb3BUeXBlcy5tYXAuaXNSZXF1aXJlZCxcbiAgICBnZXRFZGl0b3JDb21wb25lbnRzOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB2YWx1ZTogY3JlYXRlU2xhdGVWYWx1ZShwcm9wcy52YWx1ZSksXG4gICAgICBsYXN0UmF3VmFsdWU6IHByb3BzLnZhbHVlLFxuICAgIH07XG4gIH1cblxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICBjb25zdCBmb3JjZVByb3BzVmFsdWUgPSB0aGlzLnNob3VsZEZvcmNlUHJvcHNWYWx1ZShcbiAgICAgIHRoaXMucHJvcHMudmFsdWUsXG4gICAgICB0aGlzLnN0YXRlLmxhc3RSYXdWYWx1ZSxcbiAgICAgIG5leHRQcm9wcy52YWx1ZSxcbiAgICAgIG5leHRTdGF0ZS5sYXN0UmF3VmFsdWUsXG4gICAgKTtcbiAgICByZXR1cm4gIXRoaXMuc3RhdGUudmFsdWUuZXF1YWxzKG5leHRTdGF0ZS52YWx1ZSkgfHwgZm9yY2VQcm9wc1ZhbHVlO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgY29uc3QgZm9yY2VQcm9wc1ZhbHVlID0gdGhpcy5zaG91bGRGb3JjZVByb3BzVmFsdWUoXG4gICAgICBwcmV2UHJvcHMudmFsdWUsXG4gICAgICBwcmV2U3RhdGUubGFzdFJhd1ZhbHVlLFxuICAgICAgdGhpcy5wcm9wcy52YWx1ZSxcbiAgICAgIHRoaXMuc3RhdGUubGFzdFJhd1ZhbHVlLFxuICAgICk7XG5cbiAgICBpZiAoZm9yY2VQcm9wc1ZhbHVlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgdmFsdWU6IGNyZWF0ZVNsYXRlVmFsdWUodGhpcy5wcm9wcy52YWx1ZSkgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIG9sZCBwcm9wcy9zdGF0ZSB2YWx1ZXMgYW5kIG5ldyBzdGF0ZSB2YWx1ZSBhcmUgYWxsIHRoZSBzYW1lLCBhbmRcbiAgLy8gdGhlIG5ldyBwcm9wcyB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGUgb3RoZXJzLCB0aGUgbmV3IHByb3BzIHZhbHVlXG4gIC8vIG9yaWdpbmF0ZWQgZnJvbSBvdXRzaWRlIG9mIHRoaXMgd2lkZ2V0IGFuZCBzaG91bGQgYmUgdXNlZC5cbiAgc2hvdWxkRm9yY2VQcm9wc1ZhbHVlKG9sZFByb3BzVmFsdWUsIG9sZFN0YXRlVmFsdWUsIG5ld1Byb3BzVmFsdWUsIG5ld1N0YXRlVmFsdWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdW5pcShbb2xkUHJvcHNWYWx1ZSwgb2xkU3RhdGVWYWx1ZSwgbmV3U3RhdGVWYWx1ZV0pLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgb2xkUHJvcHNWYWx1ZSAhPT0gbmV3UHJvcHNWYWx1ZVxuICAgICk7XG4gIH1cblxuICBoYW5kbGVQYXN0ZSA9IChlLCBkYXRhLCBjaGFuZ2UpID0+IHtcbiAgICBpZiAoZGF0YS50eXBlICE9PSAnaHRtbCcgfHwgZGF0YS5pc1NoaWZ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFzdCA9IGh0bWxUb1NsYXRlKGRhdGEuaHRtbCk7XG4gICAgY29uc3QgZG9jID0gRG9jdW1lbnQuZnJvbUpTT04oYXN0KTtcbiAgICByZXR1cm4gY2hhbmdlLmluc2VydEZyYWdtZW50KGRvYyk7XG4gIH07XG5cbiAgc2VsZWN0aW9uSGFzTWFyayA9IHR5cGUgPT4gdGhpcy5zdGF0ZS52YWx1ZS5hY3RpdmVNYXJrcy5zb21lKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKTtcbiAgc2VsZWN0aW9uSGFzQmxvY2sgPSB0eXBlID0+IHRoaXMuc3RhdGUudmFsdWUuYmxvY2tzLnNvbWUobm9kZSA9PiBub2RlLnR5cGUgPT09IHR5cGUpO1xuXG4gIGhhbmRsZU1hcmtDbGljayA9IChldmVudCwgdHlwZSkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgcmVzb2x2ZWRDaGFuZ2UgPSB0aGlzLnN0YXRlLnZhbHVlXG4gICAgICAuY2hhbmdlKClcbiAgICAgIC5mb2N1cygpXG4gICAgICAudG9nZ2xlTWFyayh0eXBlKTtcbiAgICB0aGlzLnJlZi5vbkNoYW5nZShyZXNvbHZlZENoYW5nZSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHZhbHVlOiByZXNvbHZlZENoYW5nZS52YWx1ZSB9KTtcbiAgfTtcblxuICBoYW5kbGVCbG9ja0NsaWNrID0gKGV2ZW50LCB0eXBlKSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgeyB2YWx1ZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IGRvY3VtZW50OiBkb2MgfSA9IHZhbHVlO1xuICAgIGNvbnN0IHsgdW53cmFwTGlzdCwgd3JhcEluTGlzdCB9ID0gRWRpdExpc3RDb25maWd1cmVkLmNoYW5nZXM7XG4gICAgbGV0IGNoYW5nZSA9IHZhbHVlLmNoYW5nZSgpO1xuXG4gICAgLy8gSGFuZGxlIGV2ZXJ5dGhpbmcgZXhjZXB0IGxpc3QgYnV0dG9ucy5cbiAgICBpZiAoIVsnYnVsbGV0ZWQtbGlzdCcsICdudW1iZXJlZC1saXN0J10uaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIGNvbnN0IGlzQWN0aXZlID0gdGhpcy5zZWxlY3Rpb25IYXNCbG9jayh0eXBlKTtcbiAgICAgIGNoYW5nZSA9IGNoYW5nZS5zZXRCbG9ja3MoaXNBY3RpdmUgPyAncGFyYWdyYXBoJyA6IHR5cGUpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgZXh0cmEgd3JhcHBpbmcgcmVxdWlyZWQgZm9yIGxpc3QgYnV0dG9ucy5cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGlzU2FtZUxpc3RUeXBlID0gdmFsdWUuYmxvY2tzLnNvbWUoYmxvY2sgPT4ge1xuICAgICAgICByZXR1cm4gISFkb2MuZ2V0Q2xvc2VzdChibG9jay5rZXksIHBhcmVudCA9PiBwYXJlbnQudHlwZSA9PT0gdHlwZSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGlzSW5MaXN0ID0gRWRpdExpc3RDb25maWd1cmVkLnV0aWxzLmlzU2VsZWN0aW9uSW5MaXN0KHZhbHVlKTtcblxuICAgICAgaWYgKGlzSW5MaXN0ICYmIGlzU2FtZUxpc3RUeXBlKSB7XG4gICAgICAgIGNoYW5nZSA9IGNoYW5nZS5jYWxsKHVud3JhcExpc3QsIHR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChpc0luTGlzdCkge1xuICAgICAgICBjb25zdCBjdXJyZW50TGlzdFR5cGUgPSB0eXBlID09PSAnYnVsbGV0ZWQtbGlzdCcgPyAnbnVtYmVyZWQtbGlzdCcgOiAnYnVsbGV0ZWQtbGlzdCc7XG4gICAgICAgIGNoYW5nZSA9IGNoYW5nZS5jYWxsKHVud3JhcExpc3QsIGN1cnJlbnRMaXN0VHlwZSkuY2FsbCh3cmFwSW5MaXN0LCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYW5nZSA9IGNoYW5nZS5jYWxsKHdyYXBJbkxpc3QsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc29sdmVkQ2hhbmdlID0gY2hhbmdlLmZvY3VzKCk7XG4gICAgdGhpcy5yZWYub25DaGFuZ2UocmVzb2x2ZWRDaGFuZ2UpO1xuICAgIHRoaXMuc2V0U3RhdGUoeyB2YWx1ZTogcmVzb2x2ZWRDaGFuZ2UudmFsdWUgfSk7XG4gIH07XG5cbiAgaGFzTGlua3MgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudmFsdWUuaW5saW5lcy5zb21lKGlubGluZSA9PiBpbmxpbmUudHlwZSA9PT0gJ2xpbmsnKTtcbiAgfTtcblxuICBoYW5kbGVMaW5rID0gKCkgPT4ge1xuICAgIGxldCBjaGFuZ2UgPSB0aGlzLnN0YXRlLnZhbHVlLmNoYW5nZSgpO1xuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGNvbnRhaW5zIGxpbmtzLCBjbGlja2luZyB0aGUgXCJsaW5rXCIgYnV0dG9uXG4gICAgLy8gc2hvdWxkIHNpbXBseSB1bmxpbmsgdGhlbS5cbiAgICBpZiAodGhpcy5oYXNMaW5rcygpKSB7XG4gICAgICBjaGFuZ2UgPSBjaGFuZ2UudW53cmFwSW5saW5lKCdsaW5rJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVybCA9IHdpbmRvdy5wcm9tcHQoJ0VudGVyIHRoZSBVUkwgb2YgdGhlIGxpbmsnKTtcblxuICAgICAgLy8gSWYgbm90aGluZyBpcyBlbnRlcmVkIGluIHRoZSBVUkwgcHJvbXB0LCBkbyBub3RoaW5nLlxuICAgICAgaWYgKCF1cmwpIHJldHVybjtcblxuICAgICAgLy8gSWYgbm8gdGV4dCBpcyBzZWxlY3RlZCwgdXNlIHRoZSBlbnRlcmVkIFVSTCBhcyB0ZXh0LlxuICAgICAgaWYgKGNoYW5nZS52YWx1ZS5pc0NvbGxhcHNlZCkge1xuICAgICAgICBjaGFuZ2UgPSBjaGFuZ2UuaW5zZXJ0VGV4dCh1cmwpLmV4dGVuZCgwIC0gdXJsLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGNoYW5nZSA9IGNoYW5nZS53cmFwSW5saW5lKHsgdHlwZTogJ2xpbmsnLCBkYXRhOiB7IHVybCB9IH0pLmNvbGxhcHNlVG9FbmQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlZi5vbkNoYW5nZShjaGFuZ2UpO1xuICAgIHRoaXMuc2V0U3RhdGUoeyB2YWx1ZTogY2hhbmdlLnZhbHVlIH0pO1xuICB9O1xuXG4gIGhhbmRsZVBsdWdpbkFkZCA9IHBsdWdpbklkID0+IHtcbiAgICBjb25zdCB7IGdldEVkaXRvckNvbXBvbmVudHMgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBub2RlcyA9IFtUZXh0LmNyZWF0ZSgnJyldO1xuXG4gICAgLyoqXG4gICAgICogR2V0IGRlZmF1bHQgdmFsdWVzIGZvciBwbHVnaW4gZmllbGRzLlxuICAgICAqL1xuICAgIGNvbnN0IHBsdWdpbkZpZWxkcyA9IGdldEVkaXRvckNvbXBvbmVudHMoKS5nZXRJbihbcGx1Z2luSWQsICdmaWVsZHMnXSwgTGlzdCgpKTtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVzID0gcGx1Z2luRmllbGRzXG4gICAgICAudG9NYXAoKVxuICAgICAgLm1hcEtleXMoKF8sIGZpZWxkKSA9PiBmaWVsZC5nZXQoJ25hbWUnKSlcbiAgICAgIC5maWx0ZXIoZmllbGQgPT4gZmllbGQuaGFzKCdkZWZhdWx0JykpXG4gICAgICAubWFwKGZpZWxkID0+IGZpZWxkLmdldCgnZGVmYXVsdCcpKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBuZXcgc2hvcnRjb2RlIGJsb2NrIHdpdGggZGVmYXVsdCB2YWx1ZXMgc2V0LlxuICAgICAqL1xuICAgIGNvbnN0IGJsb2NrID0ge1xuICAgICAgb2JqZWN0OiAnYmxvY2snLFxuICAgICAgdHlwZTogJ3Nob3J0Y29kZScsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNob3J0Y29kZTogcGx1Z2luSWQsXG4gICAgICAgIHNob3J0Y29kZU5ldzogdHJ1ZSxcbiAgICAgICAgc2hvcnRjb2RlRGF0YTogZGVmYXVsdFZhbHVlcyxcbiAgICAgIH0sXG4gICAgICBpc1ZvaWQ6IHRydWUsXG4gICAgICBub2RlcyxcbiAgICB9O1xuXG4gICAgbGV0IGNoYW5nZSA9IHZhbHVlLmNoYW5nZSgpO1xuICAgIGNvbnN0IHsgZm9jdXNCbG9jayB9ID0gY2hhbmdlLnZhbHVlO1xuXG4gICAgaWYgKGZvY3VzQmxvY2sudGV4dCA9PT0gJycgJiYgZm9jdXNCbG9jay50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgY2hhbmdlID0gY2hhbmdlLnNldE5vZGVCeUtleShmb2N1c0Jsb2NrLmtleSwgYmxvY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFuZ2UgPSBjaGFuZ2UuaW5zZXJ0QmxvY2soYmxvY2spO1xuICAgIH1cblxuICAgIGNoYW5nZSA9IGNoYW5nZS5mb2N1cygpO1xuXG4gICAgdGhpcy5yZWYub25DaGFuZ2UoY2hhbmdlKTtcbiAgICB0aGlzLnNldFN0YXRlKHsgdmFsdWU6IGNoYW5nZS52YWx1ZSB9KTtcbiAgfTtcblxuICBoYW5kbGVUb2dnbGUgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vbk1vZGUoJ3JhdycpO1xuICB9O1xuXG4gIGhhbmRsZURvY3VtZW50Q2hhbmdlID0gZGVib3VuY2UoY2hhbmdlID0+IHtcbiAgICBjb25zdCB7IG9uQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHJhdyA9IGNoYW5nZS52YWx1ZS5kb2N1bWVudC50b0pTT04oKTtcbiAgICBjb25zdCBtYXJrZG93biA9IHNsYXRlVG9NYXJrZG93bihyYXcpO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBsYXN0UmF3VmFsdWU6IG1hcmtkb3duIH0sICgpID0+IG9uQ2hhbmdlKG1hcmtkb3duKSk7XG4gIH0sIDE1MCk7XG5cbiAgaGFuZGxlQ2hhbmdlID0gY2hhbmdlID0+IHtcbiAgICBpZiAoIXRoaXMuc3RhdGUudmFsdWUuZG9jdW1lbnQuZXF1YWxzKGNoYW5nZS52YWx1ZS5kb2N1bWVudCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlRG9jdW1lbnRDaGFuZ2UoY2hhbmdlKTtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHZhbHVlOiBjaGFuZ2UudmFsdWUgfSk7XG4gIH07XG5cbiAgcHJvY2Vzc1JlZiA9IHJlZiA9PiB7XG4gICAgdGhpcy5yZWYgPSByZWY7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgb25BZGRBc3NldCwgZ2V0QXNzZXQsIGNsYXNzTmFtZSwgZmllbGQsIGdldEVkaXRvckNvbXBvbmVudHMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFZpc3VhbEVkaXRvckNvbnRhaW5lcj5cbiAgICAgICAgPEVkaXRvckNvbnRyb2xCYXI+XG4gICAgICAgICAgPFRvb2xiYXJcbiAgICAgICAgICAgIG9uTWFya0NsaWNrPXt0aGlzLmhhbmRsZU1hcmtDbGlja31cbiAgICAgICAgICAgIG9uQmxvY2tDbGljaz17dGhpcy5oYW5kbGVCbG9ja0NsaWNrfVxuICAgICAgICAgICAgb25MaW5rQ2xpY2s9e3RoaXMuaGFuZGxlTGlua31cbiAgICAgICAgICAgIHNlbGVjdGlvbkhhc01hcms9e3RoaXMuc2VsZWN0aW9uSGFzTWFya31cbiAgICAgICAgICAgIHNlbGVjdGlvbkhhc0Jsb2NrPXt0aGlzLnNlbGVjdGlvbkhhc0Jsb2NrfVxuICAgICAgICAgICAgc2VsZWN0aW9uSGFzTGluaz17dGhpcy5oYXNMaW5rc31cbiAgICAgICAgICAgIG9uVG9nZ2xlTW9kZT17dGhpcy5oYW5kbGVUb2dnbGV9XG4gICAgICAgICAgICBwbHVnaW5zPXtnZXRFZGl0b3JDb21wb25lbnRzKCl9XG4gICAgICAgICAgICBvblN1Ym1pdD17dGhpcy5oYW5kbGVQbHVnaW5BZGR9XG4gICAgICAgICAgICBvbkFkZEFzc2V0PXtvbkFkZEFzc2V0fVxuICAgICAgICAgICAgZ2V0QXNzZXQ9e2dldEFzc2V0fVxuICAgICAgICAgICAgYnV0dG9ucz17ZmllbGQuZ2V0KCdidXR0b25zJyl9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JDb250cm9sQmFyPlxuICAgICAgICA8Q2xhc3NOYW1lcz5cbiAgICAgICAgICB7KHsgY3NzLCBjeCB9KSA9PiAoXG4gICAgICAgICAgICA8U2xhdGVcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgY3NzYFxuICAgICAgICAgICAgICAgICAgJHt2aXN1YWxFZGl0b3JTdHlsZXN9XG4gICAgICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUudmFsdWV9XG4gICAgICAgICAgICAgIHJlbmRlck5vZGU9e3JlbmRlck5vZGV9XG4gICAgICAgICAgICAgIHJlbmRlck1hcms9e3JlbmRlck1hcmt9XG4gICAgICAgICAgICAgIHZhbGlkYXRlTm9kZT17dmFsaWRhdGVOb2RlfVxuICAgICAgICAgICAgICBwbHVnaW5zPXtwbHVnaW5zfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgICAgIG9uS2V5RG93bj17b25LZXlEb3dufVxuICAgICAgICAgICAgICBvblBhc3RlPXt0aGlzLmhhbmRsZVBhc3RlfVxuICAgICAgICAgICAgICByZWY9e3RoaXMucHJvY2Vzc1JlZn1cbiAgICAgICAgICAgICAgc3BlbGxDaGVja1xuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICA8L0NsYXNzTmFtZXM+XG4gICAgICA8L1Zpc3VhbEVkaXRvckNvbnRhaW5lcj5cbiAgICApO1xuICB9XG59XG4iXX0= */"
});

const createEmptyRawDoc = () => {
  const emptyText = _slate.Text.create('');

  const emptyBlock = _slate.Block.create({
    object: 'block',
    type: 'paragraph',
    nodes: [emptyText]
  });

  return {
    nodes: [emptyBlock]
  };
};

const createSlateValue = rawValue => {
  const rawDoc = rawValue && (0, _serializers.markdownToSlate)(rawValue);
  const rawDocHasNodes = !(0, _isEmpty2.default)((0, _get2.default)(rawDoc, 'nodes'));

  const document = _slate.Document.fromJSON(rawDocHasNodes ? rawDoc : createEmptyRawDoc());

  return _slate.Value.create({
    document
  });
};

class Editor extends _react.default.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "handlePaste", (e, data, change) => {
      if (data.type !== 'html' || data.isShift) {
        return;
      }

      const ast = (0, _serializers.htmlToSlate)(data.html);

      const doc = _slate.Document.fromJSON(ast);

      return change.insertFragment(doc);
    });

    _defineProperty(this, "selectionHasMark", type => this.state.value.activeMarks.some(mark => mark.type === type));

    _defineProperty(this, "selectionHasBlock", type => this.state.value.blocks.some(node => node.type === type));

    _defineProperty(this, "handleMarkClick", (event, type) => {
      event.preventDefault();
      const resolvedChange = this.state.value.change().focus().toggleMark(type);
      this.ref.onChange(resolvedChange);
      this.setState({
        value: resolvedChange.value
      });
    });

    _defineProperty(this, "handleBlockClick", (event, type) => {
      event.preventDefault();
      let value = this.state.value;
      const doc = value.document;
      const _EditListConfigured$c = _plugins.EditListConfigured.changes,
            unwrapList = _EditListConfigured$c.unwrapList,
            wrapInList = _EditListConfigured$c.wrapInList;
      let change = value.change(); // Handle everything except list buttons.

      if (!['bulleted-list', 'numbered-list'].includes(type)) {
        const isActive = this.selectionHasBlock(type);
        change = change.setBlocks(isActive ? 'paragraph' : type);
      } // Handle the extra wrapping required for list buttons.
      else {
          const isSameListType = value.blocks.some(block => {
            return !!doc.getClosest(block.key, parent => parent.type === type);
          });

          const isInList = _plugins.EditListConfigured.utils.isSelectionInList(value);

          if (isInList && isSameListType) {
            change = change.call(unwrapList, type);
          } else if (isInList) {
            const currentListType = type === 'bulleted-list' ? 'numbered-list' : 'bulleted-list';
            change = change.call(unwrapList, currentListType).call(wrapInList, type);
          } else {
            change = change.call(wrapInList, type);
          }
        }

      const resolvedChange = change.focus();
      this.ref.onChange(resolvedChange);
      this.setState({
        value: resolvedChange.value
      });
    });

    _defineProperty(this, "hasLinks", () => {
      return this.state.value.inlines.some(inline => inline.type === 'link');
    });

    _defineProperty(this, "handleLink", () => {
      let change = this.state.value.change(); // If the current selection contains links, clicking the "link" button
      // should simply unlink them.

      if (this.hasLinks()) {
        change = change.unwrapInline('link');
      } else {
        const url = window.prompt('Enter the URL of the link'); // If nothing is entered in the URL prompt, do nothing.

        if (!url) return; // If no text is selected, use the entered URL as text.

        if (change.value.isCollapsed) {
          change = change.insertText(url).extend(0 - url.length);
        }

        change = change.wrapInline({
          type: 'link',
          data: {
            url
          }
        }).collapseToEnd();
      }

      this.ref.onChange(change);
      this.setState({
        value: change.value
      });
    });

    _defineProperty(this, "handlePluginAdd", pluginId => {
      const getEditorComponents = this.props.getEditorComponents;
      const value = this.state.value;
      const nodes = [_slate.Text.create('')];
      /**
       * Get default values for plugin fields.
       */

      const pluginFields = getEditorComponents().getIn([pluginId, 'fields'], (0, _immutable.List)());
      const defaultValues = pluginFields.toMap().mapKeys((_, field) => field.get('name')).filter(field => field.has('default')).map(field => field.get('default'));
      /**
       * Create new shortcode block with default values set.
       */

      const block = {
        object: 'block',
        type: 'shortcode',
        data: {
          shortcode: pluginId,
          shortcodeNew: true,
          shortcodeData: defaultValues
        },
        isVoid: true,
        nodes
      };
      let change = value.change();
      const focusBlock = change.value.focusBlock;

      if (focusBlock.text === '' && focusBlock.type === 'paragraph') {
        change = change.setNodeByKey(focusBlock.key, block);
      } else {
        change = change.insertBlock(block);
      }

      change = change.focus();
      this.ref.onChange(change);
      this.setState({
        value: change.value
      });
    });

    _defineProperty(this, "handleToggle", () => {
      this.props.onMode('raw');
    });

    _defineProperty(this, "handleDocumentChange", (0, _debounce2.default)(change => {
      const onChange = this.props.onChange;
      const raw = change.value.document.toJSON();
      const markdown = (0, _serializers.slateToMarkdown)(raw);
      this.setState({
        lastRawValue: markdown
      }, () => onChange(markdown));
    }, 150));

    _defineProperty(this, "handleChange", change => {
      if (!this.state.value.document.equals(change.value.document)) {
        this.handleDocumentChange(change);
      }

      this.setState({
        value: change.value
      });
    });

    _defineProperty(this, "processRef", ref => {
      this.ref = ref;
    });

    this.state = {
      value: createSlateValue(props.value),
      lastRawValue: props.value
    };
  }

  shouldComponentUpdate(nextProps, nextState) {
    const forcePropsValue = this.shouldForcePropsValue(this.props.value, this.state.lastRawValue, nextProps.value, nextState.lastRawValue);
    return !this.state.value.equals(nextState.value) || forcePropsValue;
  }

  componentDidUpdate(prevProps, prevState) {
    const forcePropsValue = this.shouldForcePropsValue(prevProps.value, prevState.lastRawValue, this.props.value, this.state.lastRawValue);

    if (forcePropsValue) {
      this.setState({
        value: createSlateValue(this.props.value)
      });
    }
  } // If the old props/state values and new state value are all the same, and
  // the new props value does not match the others, the new props value
  // originated from outside of this widget and should be used.


  shouldForcePropsValue(oldPropsValue, oldStateValue, newPropsValue, newStateValue) {
    return (0, _uniq2.default)([oldPropsValue, oldStateValue, newStateValue]).length === 1 && oldPropsValue !== newPropsValue;
  }

  render() {
    const _this$props = this.props,
          onAddAsset = _this$props.onAddAsset,
          getAsset = _this$props.getAsset,
          className = _this$props.className,
          field = _this$props.field,
          getEditorComponents = _this$props.getEditorComponents;
    return _react.default.createElement(VisualEditorContainer, null, _react.default.createElement(_styles.EditorControlBar, null, _react.default.createElement(_Toolbar.default, {
      onMarkClick: this.handleMarkClick,
      onBlockClick: this.handleBlockClick,
      onLinkClick: this.handleLink,
      selectionHasMark: this.selectionHasMark,
      selectionHasBlock: this.selectionHasBlock,
      selectionHasLink: this.hasLinks,
      onToggleMode: this.handleToggle,
      plugins: getEditorComponents(),
      onSubmit: this.handlePluginAdd,
      onAddAsset: onAddAsset,
      getAsset: getAsset,
      buttons: field.get('buttons')
    })), _react.default.createElement(_core.ClassNames, null, (_ref) => {
      let css = _ref.css,
          cx = _ref.cx;
      return _react.default.createElement(_slateReact.Editor, {
        className: cx(className, css`
                  ${_visualEditorStyles.default}
                `),
        value: this.state.value,
        renderNode: _renderers.renderNode,
        renderMark: _renderers.renderMark,
        validateNode: _validators.validateNode,
        plugins: _plugins.default,
        onChange: this.handleChange,
        onKeyDown: _keys.default,
        onPaste: this.handlePaste,
        ref: this.processRef,
        spellCheck: true
      });
    }));
  }

}

exports.default = Editor;

_defineProperty(Editor, "propTypes", {
  onAddAsset: _propTypes.default.func.isRequired,
  getAsset: _propTypes.default.func.isRequired,
  onChange: _propTypes.default.func.isRequired,
  onMode: _propTypes.default.func.isRequired,
  className: _propTypes.default.string.isRequired,
  value: _propTypes.default.string,
  field: _reactImmutableProptypes.default.map.isRequired,
  getEditorComponents: _propTypes.default.func.isRequired
});