"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = remarkShortcodes;

var _every2 = _interopRequireDefault(require("lodash/every"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _unistBuilder = _interopRequireDefault(require("unist-builder"));

var _mdastUtilToString = _interopRequireDefault(require("mdast-util-to-string"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Parse shortcodes from an MDAST.
 *
 * Shortcodes are plain text, and must be the lone content of a paragraph. The
 * paragraph must also be a direct child of the root node. When a shortcode is
 * found, we just need to add data to the node so the shortcode can be
 * identified and processed when serializing to a new format. The paragraph
 * containing the node is also recreated to ensure normalization.
 */
function remarkShortcodes(_ref) {
  let plugins = _ref.plugins;
  return transform;
  /**
   * Map over children of the root node and convert any found shortcode nodes.
   */

  function transform(root) {
    const transformedChildren = (0, _map2.default)(root.children, processShortcodes);
    return _objectSpread({}, root, {
      children: transformedChildren
    });
  }
  /**
   * Mapping function to transform nodes that contain shortcodes.
   */


  function processShortcodes(node) {
    /**
     * If the node is not eligible to contain a shortcode, return the original
     * node unchanged.
     */
    if (!nodeMayContainShortcode(node)) return node;
    /**
     * Combine the text values of all children to a single string, check the
     * string for a shortcode pattern match, and validate the match.
     */

    const text = (0, _mdastUtilToString.default)(node).trim();

    const _matchTextToPlugin = matchTextToPlugin(text),
          plugin = _matchTextToPlugin.plugin,
          match = _matchTextToPlugin.match;

    const matchIsValid = validateMatch(text, match);
    /**
     * If a valid match is found, return a new node with shortcode data
     * included. Otherwise, return the original node.
     */

    return matchIsValid ? createShortcodeNode(text, plugin, match) : node;
  }
  /**
   * Ensure that the node and it's children are acceptable types to contain
   * shortcodes. Currently, only a paragraph containing text and/or html nodes
   * may contain shortcodes.
   */


  function nodeMayContainShortcode(node) {
    const validNodeTypes = ['paragraph'];
    const validChildTypes = ['text', 'html'];

    if (validNodeTypes.includes(node.type)) {
      return (0, _every2.default)(node.children, child => {
        return validChildTypes.includes(child.type);
      });
    }
  }
  /**
   * Return the plugin and RegExp.match result from the first plugin with a
   * pattern that matches the given text.
   */


  function matchTextToPlugin(text) {
    let match;
    const plugin = plugins.find(p => {
      match = text.match(p.pattern);
      return !!match;
    });
    return {
      plugin,
      match
    };
  }
  /**
   * A match is only valid if it takes up the entire paragraph.
   */


  function validateMatch(text, match) {
    return match && match[0].length === text.length;
  }
  /**
   * Create a new node with shortcode data included. Use an 'html' node instead
   * of a 'text' node as the child to ensure the node content is not parsed by
   * Remark or Rehype. Include the child as an array because an MDAST paragraph
   * node must have it's children in an array.
   */


  function createShortcodeNode(text, plugin, match) {
    const shortcode = plugin.id;
    const shortcodeData = plugin.fromBlock(match);
    const data = {
      shortcode,
      shortcodeData
    };
    const textNode = (0, _unistBuilder.default)('html', text);
    return (0, _unistBuilder.default)('paragraph', {
      data
    }, [textNode]);
  }
}